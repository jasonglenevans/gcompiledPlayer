{"version":3,"sources":["node_modules/browser-pack/_prelude.js","index.js","node_modules/base64-js/index.js","node_modules/buffer/index.js","node_modules/ieee754/index.js","src/midi.js","src/midi2wav.js","src/utils/timer.js","src/wav.js"],"names":["f","exports","module","define","amd","g","window","global","self","this","synth","r","e","n","t","o","i","c","require","u","a","Error","code","p","call","length","1","WAV","MIDIStream","midiToWav","getLens","b64","len","validLen","indexOf","byteLength","lens","placeHoldersLen","_byteLength","toByteArray","tmp","arr","Arr","curByte","revLookup","charCodeAt","tripletToBase64","num","lookup","encodeChunk","uint8","start","end","output","push","join","fromByteArray","extraBytes","parts","len2","Uint8Array","Array","createBuffer","K_MAX_LENGTH","RangeError","buf","Object","setPrototypeOf","Buffer","prototype","arg","encodingOrOffset","TypeError","allocUnsafe","from","value","fromString","ArrayBuffer","isView","fromArrayLike","isInstance","buffer","fromArrayBuffer","SharedArrayBuffer","valueOf","b","fromObject","Symbol","toPrimitive","assertSize","size","alloc","fill","encoding","undefined","checked","string","isEncoding","actual","write","slice","array","byteOffset","obj","isBuffer","copy","numberIsNaN","type","isArray","data","toString","SlowBuffer","mustMatch","arguments","loweredCase","utf8ToBytes","base64ToBytes","toLowerCase","slowToString","hexSlice","utf8Slice","asciiSlice","latin1Slice","base64Slice","utf16leSlice","swap","m","bidirectionalIndexOf","val","dir","arrayIndexOf","lastIndexOf","read","indexSize","readUInt16BE","arrLength","valLength","String","foundIndex","found","j","hexWrite","offset","Number","remaining","strLen","parsed","parseInt","substr","utf8Write","blitBuffer","asciiWrite","asciiToBytes","latin1Write","base64Write","ucs2Write","utf16leToBytes","base64","Math","min","res","firstByte","codePoint","bytesPerSequence","secondByte","thirdByte","fourthByte","tempCodePoint","decodeCodePointsArray","codePoints","MAX_ARGUMENTS_LENGTH","fromCharCode","apply","ret","out","hexSliceLookupTable","bytes","checkOffset","ext","checkInt","max","checkIEEE754","writeFloat","littleEndian","noAssert","ieee754","writeDouble","base64clean","str","split","trim","replace","INVALID_BASE64_RE","units","Infinity","leadSurrogate","byteArray","hi","lo","src","dst","constructor","name","customInspectSymbol","for","INSPECT_MAX_BYTES","kMaxLength","TYPED_ARRAY_SUPPORT","proto","foo","console","error","defineProperty","enumerable","get","poolSize","allocUnsafeSlow","_isBuffer","compare","x","y","concat","list","pos","swap16","swap32","swap64","toLocaleString","equals","inspect","target","thisStart","thisEnd","thisCopy","targetCopy","includes","isFinite","toJSON","_arr","newBuf","subarray","readUIntLE","mul","readUIntBE","readUInt8","readUInt16LE","readUInt32LE","readUInt32BE","readIntLE","pow","readIntBE","readInt8","readInt16LE","readInt16BE","readInt32LE","readInt32BE","readFloatLE","readFloatBE","readDoubleLE","readDoubleBE","writeUIntLE","writeUIntBE","writeUInt8","writeUInt16LE","writeUInt16BE","writeUInt32LE","writeUInt32BE","writeIntLE","limit","sub","writeIntBE","writeInt8","writeInt16LE","writeInt16BE","writeInt32LE","writeInt32BE","writeFloatLE","writeFloatBE","writeDoubleLE","writeDoubleBE","targetStart","copyWithin","set","table","i16","isLE","mLen","nBytes","eLen","eMax","eBias","nBits","d","s","NaN","rt","abs","isNaN","floor","log","LN2","_classCallCheck","lastEventTypeByte","readUint8","id","readString","readUint32","event","delta","readVarUint","eventTypeByte","subTypeByte","subType","readUint16","skip","readUint24","hourByte","frameRate","0","2","3","hour","minute","second","frame","subFrame","numerator","denominator","metronome","thirtyseconds","key","scale","param","eventType","channel","noteNumber","velocity","amount","controllerNumber","controllerValue","Timer","args","verbose","midiStream","header","readChunk","SyntaxError","headerStream","trackCount","timeDivision","tracks","progression","events","maxAmplitude","trackChunk","trackStream","track","keep","readEvent","Skip","timer","_event","_i","ticks","addCriticalPoint","_i2","_track","_delta","map","Map","_event2","semitone","_velocity","getTime","has","note","notes","pop","time","amplitude","toFixed","sort","maxVelocity","maxVelocityTime","maxChord","maxChordTime","chord","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","iterator","next","done","_event3","err","return","channels","wav","sampleRate","bitsPerSample","writeProgression","duration","ticksPerBeat","criticalPoints","microsecondsPerBeat","criticalPoint","numChannels","bytesPerSample","view","DataView","configurable","writable","pointer","ChunkID","ChunkSize","Format","SubChunk1ID","SubChunk1Size","AudioFormat","NumChannels","SampleRate","ByteRate","BlockAlign","BitsPerSample","SubChunk2ID","SubChunk2Size","re","test","_note$match","match","_note$match2","_slicedToArray","tone","octave","accidental","tones","C","D","E","F","G","A","B","octaves","-1","4","5","6","7","8","9","10","accidentals","bb","","#","##","octaveIndex","toneIndex","charAt","setUint8","getUint8","Blob","typedData","sample","round","k","_ref","_ref$amplitude","blend","reset","frequency","PI","blocksOut","nonZero","fade","stop","blocksIn","skipChannel","sin","amp","off","secs","rest","relativeDuration","_notes$i","seek","writeNote","setString","getString","uint","setUint32","getUint32","setUint16","getUint16","samples"],"mappings":"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","file":"synth.min.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","'use strict';\r\n\r\nmodule.exports = {\r\n  WAV: require('./src/wav'),\r\n  MIDIStream: require('./src/midi'),\r\n  midiToWav: require('./src/midi2wav')\r\n};\r\n","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(\n      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\n    ))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar customInspectSymbol =\n  (typeof Symbol === 'function' && typeof Symbol.for === 'function')\n    ? Symbol.for('nodejs.util.inspect.custom')\n    : null\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nvar K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    var arr = new Uint8Array(1)\n    var proto = { foo: function () { return 42 } }\n    Object.setPrototypeOf(proto, Uint8Array.prototype)\n    Object.setPrototypeOf(arr, proto)\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  var buf = new Uint8Array(length)\n  Object.setPrototypeOf(buf, Buffer.prototype)\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayLike(value)\n  }\n\n  if (value == null) {\n    throw new TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof SharedArrayBuffer !== 'undefined' &&\n      (isInstance(value, SharedArrayBuffer) ||\n      (value && isInstance(value.buffer, SharedArrayBuffer)))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  var valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  var b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(\n      value[Symbol.toPrimitive]('string'), encodingOrOffset, length\n    )\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)\nObject.setPrototypeOf(Buffer, Uint8Array)\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  var length = byteLength(string, encoding) | 0\n  var buf = createBuffer(length)\n\n  var actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  var buf = createBuffer(length)\n  for (var i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  var buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(buf, Buffer.prototype)\n\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    var buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      buf = Buffer.from(buf)\n    }\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  var len = string.length\n  var mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\nif (customInspectSymbol) {\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  var strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n        : (firstByte > 0xBF) ? 2\n          : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += hexSliceLookupTable[buf[i]]\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(newBuf, Buffer.prototype)\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (var i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  } else if (typeof val === 'boolean') {\n    val = Number(val)\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    var len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nvar hexSliceLookupTable = (function () {\n  var alphabet = '0123456789abcdef'\n  var table = new Array(256)\n  for (var i = 0; i < 16; ++i) {\n    var i16 = i * 16\n    for (var j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j]\n    }\n  }\n  return table\n})()\n","exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n","'use strict';\r\n\r\nclass MIDIStream {\r\n  constructor(buffer) {\r\n    this.data = new Uint8Array(buffer);\r\n    this.byteOffset = 0;\r\n    this.lastEventTypeByte = 0x00;\r\n  }\r\n\r\n  readString(byteLength) {\r\n    var byteOffset = this.byteOffset;\r\n\r\n    for (var i = 0, str = ''; i < byteLength; i++) {\r\n      str += String.fromCharCode(this.data[byteOffset + i]);\r\n    }\r\n\r\n    this.byteOffset += byteLength;\r\n\r\n    return str;\r\n  }\r\n\r\n  readUint32() {\r\n    var byteOffset = this.byteOffset;\r\n    var value = (\r\n      (this.data[byteOffset    ] << 24) |\r\n      (this.data[byteOffset + 1] << 16) |\r\n      (this.data[byteOffset + 2] <<  8) |\r\n      (this.data[byteOffset + 3]      )\r\n    );\r\n\r\n    this.byteOffset += 4;\r\n\r\n    return value;\r\n  }\r\n\r\n  readUint24() {\r\n    var byteOffset = this.byteOffset;\r\n    var value = (\r\n      (this.data[byteOffset    ] << 16) |\r\n      (this.data[byteOffset + 1] <<  8) |\r\n      (this.data[byteOffset + 2]      )\r\n    );\r\n\r\n    this.byteOffset += 3;\r\n\r\n    return value;\r\n  }\r\n\r\n  readUint16() {\r\n    var byteOffset = this.byteOffset;\r\n    var value = (\r\n      (this.data[byteOffset    ] << 8) |\r\n      (this.data[byteOffset + 1]     )\r\n    );\r\n\r\n    this.byteOffset += 2;\r\n\r\n    return value;\r\n  }\r\n\r\n  readUint8() {\r\n    var byteOffset = this.byteOffset;\r\n    var value = this.data[byteOffset];\r\n\r\n    this.byteOffset += 1;\r\n\r\n    return value;\r\n  }\r\n\r\n  readInt8() {\r\n    var byteOffset = this.byteOffset;\r\n    var value = this.data[byteOffset];\r\n\r\n    if (value & 0x80 === 0x80) {\r\n      value ^= 0xFFFFFF00;\r\n    }\r\n\r\n    this.byteOffset += 1;\r\n\r\n    return value;\r\n  }\r\n\r\n  readVarUint() {\r\n    var value = 0;\r\n    var uint8;\r\n\r\n    do {\r\n      uint8 = this.readUint8();\r\n      value = (value << 7) + (uint8 & 0x7F);\r\n    } while ((uint8 & 0x80) === 0x80);\r\n\r\n    return value;\r\n  }\r\n\r\n  skip(byteLength) {\r\n    this.byteOffset += byteLength;\r\n  }\r\n\r\n  readChunk() {\r\n    var id = this.readString(4);\r\n    var length = this.readUint32();\r\n    var byteOffset = this.byteOffset;\r\n\r\n    this.byteOffset += length;\r\n\r\n    var data = this.data.slice(byteOffset, this.byteOffset);\r\n\r\n    return {\r\n      id: id,\r\n      length: length,\r\n      data: data.buffer\r\n    };\r\n  }\r\n\r\n  readEvent() {\r\n    var event = {};\r\n\r\n    event.delta = this.readVarUint();\r\n\r\n    var eventTypeByte = this.readUint8();\r\n\r\n    // system event\r\n    if ((eventTypeByte & 0xF0) === 0xF0) {\r\n      switch (eventTypeByte) {\r\n      // meta event\r\n      case 0xFF:\r\n        event.type = 'meta';\r\n\r\n        var subTypeByte = this.readUint8();\r\n        var length = this.readVarUint();\r\n\r\n        switch (subTypeByte) {\r\n        case 0x00:\r\n          event.subType = 'sequenceNumber';\r\n          if (length === 2)\r\n            event.value = this.readUint16();\r\n          else\r\n            this.skip(length);\r\n          break;\r\n        case 0x01:\r\n          event.subType = 'text';\r\n          event.value = this.readString(length);\r\n          break;\r\n        case 0x02:\r\n          event.subType = 'copyrightNotice';\r\n          event.value = this.readString(length);\r\n          break;\r\n        case 0x03:\r\n          event.subType = 'trackName';\r\n          event.value = this.readString(length);\r\n          break;\r\n        case 0x04:\r\n          event.subType = 'instrumentName';\r\n          event.value = this.readString(length);\r\n          break;\r\n        case 0x05:\r\n          event.subType = 'lyrics';\r\n          event.value = this.readString(length);\r\n          break;\r\n        case 0x06:\r\n          event.subType = 'marker';\r\n          event.value = this.readString(length);\r\n          break;\r\n        case 0x07:\r\n          event.subType = 'cuePoint';\r\n          event.value = this.readString(length);\r\n          break;\r\n        case 0x20:\r\n          event.subType = 'midiChannelPrefix';\r\n          if (length === 1)\r\n            event.value = this.readUint8();\r\n          else\r\n            this.skip(length);\r\n          break;\r\n        case 0x2F:\r\n          event.subType = 'endOfTrack';\r\n          if (length > 0)\r\n            this.skip(length);\r\n          break;\r\n        case 0x51:\r\n          event.subType = 'setTempo';\r\n          if (length === 3)\r\n            event.value = this.readUint24();\r\n          else\r\n            this.skip(length)\r\n          break;\r\n        case 0x54:\r\n          event.subType = 'smpteOffset';\r\n          if (length === 5) {\r\n            var hourByte = this.readUint8();\r\n            event.value = {\r\n              frameRate: ({\r\n                0x00: 24,\r\n                0x01: 25,\r\n                0x02: 29.97,\r\n                0x03: 30\r\n              }[hourByte >>> 6]),\r\n              hour: (hourByte & 0x3F),\r\n              minute: this.readUint8(),\r\n              second: this.readUint8(),\r\n              frame: this.readUint8(),\r\n              subFrame: this.readUint8()\r\n            };\r\n          } else {\r\n            this.skip(length);\r\n          }\r\n          break;\r\n        case 0x58:\r\n          event.subType = 'timeSignature';\r\n          if (length === 4) {\r\n            event.value = {\r\n              numerator: this.readUint8(),\r\n              denominator: 1 << this.readUint8(),\r\n              metronome: this.readUint8(),\r\n              thirtyseconds: this.readUint8()\r\n            };\r\n          } else {\r\n            this.skip(length);\r\n          }\r\n          break;\r\n        case 0x59:\r\n          event.subType = 'keySignature';\r\n          if (length === 2) {\r\n            event.value = {\r\n              key: this.readInt8(),\r\n              scale: this.readUint8()\r\n            };\r\n          } else {\r\n            this.skip(length);\r\n          }\r\n          break;\r\n        case 0x7F:\r\n          event.subType = 'sequencerSpecific';\r\n          event.value = this.readString(length);\r\n          break;\r\n        default:\r\n          event.subType = 'unknown';\r\n          event.value = this.readString(length);\r\n        }\r\n        break;\r\n      // sysex event\r\n      case 0xF0:\r\n        event.type = 'sysEx';\r\n\r\n        var length = this.readVarUint();\r\n\r\n        event.value = this.readString(length);\r\n\r\n        break;\r\n      case 0xF7:\r\n        event.type = 'dividedSysEx';\r\n\r\n        var length = this.readVarUint();\r\n\r\n        event.value = this.readString(length);\r\n\r\n        break;\r\n      default:\r\n        event.type = 'unknown';\r\n\r\n        var length = this.readVarUint();\r\n\r\n        event.value = this.readString(length);\r\n      }\r\n    // channel event\r\n    } else {\r\n      var param;\r\n\r\n      // if the high bit is low\r\n      // use running event type mode\r\n      if ((eventTypeByte & 0x80) === 0x00) {\r\n        param = eventTypeByte;\r\n        eventTypeByte = this.lastEventTypeByte;\r\n      } else {\r\n        param = this.readUint8();\r\n        this.lastEventTypeByte = eventTypeByte;\r\n      }\r\n\r\n      var eventType = eventTypeByte >> 4;\r\n\r\n      event.channel = eventTypeByte & 0x0F;\r\n      event.type = 'channel';\r\n\r\n      switch (eventType) {\r\n      case 0x08:\r\n        event.subType = 'noteOff';\r\n\r\n        event.value = {\r\n          noteNumber: param,\r\n          velocity: this.readUint8()\r\n        };\r\n        break;\r\n      case 0x09:\r\n        event.value = {\r\n          noteNumber: param,\r\n          velocity: this.readUint8()\r\n        };\r\n\r\n        // some midi implementations use a noteOn\r\n        // event with 0 velocity to denote noteOff\r\n        if (event.value.velocity === 0) {\r\n          event.subType = 'noteOff';\r\n        } else {\r\n          event.subType = 'noteOn';\r\n        }\r\n        break;\r\n      case 0x0A:\r\n        event.subType = 'noteAftertouch';\r\n\r\n        event.value = {\r\n          noteNumber: param,\r\n          amount: this.readUint8()\r\n        };\r\n        break;\r\n      case 0x0B:\r\n        event.subType = 'controller';\r\n\r\n        event.value = {\r\n          controllerNumber: param,\r\n          controllerValue: this.readUint8()\r\n        };\r\n        break;\r\n      case 0x0C:\r\n        event.subType = 'programChange';\r\n        event.value = param;\r\n        break;\r\n      case 0x0D:\r\n        event.subType = 'channelAftertouch';\r\n        event.value = param;\r\n        break;\r\n      case 0x0E:\r\n        event.subType = 'pitchBend';\r\n        event.value = param + (this.readUint8() << 7);\r\n        break;\r\n      default:\r\n        event.subType = 'unknown';\r\n        event.value = (param << 8) + this.readUint8();\r\n      }\r\n    }\r\n\r\n    return event;\r\n  }\r\n};\r\n\r\nmodule.exports = MIDIStream;\r\n","'use strict';\r\n\r\nconst WAV = require('./wav');\r\nconst MIDIStream = require('./midi');\r\nconst Timer = require('./utils/timer');\r\n\r\nmodule.exports = function midiToWav(buffer, args = {}) {\r\n  if (args.verbose) {\r\n    console.log('parsing MIDI header...');\r\n  }\r\n\r\n  const midiStream = new MIDIStream(buffer);\r\n  const header = midiStream.readChunk();\r\n\r\n  if (header.id !== 'MThd' || header.length !== 6) {\r\n    throw new SyntaxError('malformed header');\r\n  }\r\n\r\n  const headerStream = new MIDIStream(header.data);\r\n  const formatType = headerStream.readUint16();\r\n  const trackCount = headerStream.readUint16();\r\n  const timeDivision = headerStream.readUint16();\r\n  const tracks = [];\r\n  const progression = [];\r\n  const events = [];\r\n  let maxAmplitude;\r\n\r\n  for (let i = 0; i < trackCount; i++) {\r\n    if (args.verbose) {\r\n      console.log(`parsing track ${i + 1}...`);\r\n    }\r\n\r\n    const trackChunk = midiStream.readChunk();\r\n\r\n    if (trackChunk.id !== 'MTrk') {\r\n      continue;\r\n    }\r\n\r\n    const trackStream = new MIDIStream(trackChunk.data);\r\n    const track = [];\r\n    let keep = true;\r\n\r\n    // determine whether applied filter will remove the current track while populating it\r\n    while (keep && trackStream.byteOffset < trackChunk.length) {\r\n      let event = trackStream.readEvent();\r\n      track.push(event);\r\n\r\n      if (typeof event.value === 'string') {\r\n        if (args.verbose) {\r\n          console.log(`{\"${event.subType}\":\"${event.value}\"}`);\r\n        }\r\n\r\n        if (Array.isArray(args.Skip)) {\r\n          for (let t = 0; t < args.Skip.length; t++) {\r\n            if (args.Skip[t][event.subType] === event.value) {\r\n              if (args.verbose) {\r\n                console.log(`skip match found: {\"${event.subType}\":\"${event.value}\"}`);\r\n              }\r\n\r\n              keep = false;\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (typeof args.Skip === 'function') {\r\n      keep = !args.Skip(track);\r\n    }\r\n\r\n    if (keep) {\r\n      tracks.push(track);\r\n    } else if (args.verbose) {\r\n      console.log(`skipping track ${i + 1}...`);\r\n    }\r\n  }\r\n\r\n  if (timeDivision >>> 15 === 0) {\r\n    // use microseconds per beat\r\n    const timer = new Timer(timeDivision);\r\n\r\n    if (args.verbose) {\r\n      console.log('initializing timer...');\r\n    }\r\n\r\n    // set up timer with setTempo events\r\n    for (let i = 0, delta = 0, ticks = 0, event; i < tracks[0].length; i++) {\r\n      event = tracks[0][i];\r\n      delta += event.delta;\r\n      ticks += event.delta;\r\n\r\n      if (event.subType === 'setTempo') {\r\n        timer.addCriticalPoint(delta, event.value);\r\n        delta = 0;\r\n      }\r\n    }\r\n\r\n    // generate note data\r\n    for (let i = 0; i < tracks.length; i++) {\r\n      if (args.verbose) {\r\n        console.log(`generating progression from track ${i + 1}...`);\r\n      }\r\n\r\n      let track = tracks[i];\r\n      let delta = 0;\r\n      let map = new Map();\r\n\r\n      for (let j = 0; j < track.length; j++) {\r\n        let event = track[j];\r\n        delta += event.delta;\r\n\r\n        if (event.type === 'channel') {\r\n          const semitone = event.value.noteNumber;\r\n\r\n          if (event.subType === 'noteOn') {\r\n            let velocity = event.value.velocity;\r\n            let offset = timer.getTime(delta);\r\n\r\n            // use stack for simultaneous identical notes\r\n            if (map.has(semitone)) {\r\n              map.get(semitone).push({offset, velocity});\r\n            } else {\r\n              map.set(semitone, [{offset, velocity}]);\r\n            }\r\n\r\n            // to determine maximum total velocity for normalizing volume\r\n            events.push({velocity, delta, note: true});\r\n          } else if (event.subType === 'noteOff') {\r\n            const notes = map.get(semitone);\r\n\t          const note = notes ? notes.pop() : { offset: 0, velocity: 0 };\r\n\r\n            progression.push({\r\n              note: WAV.note(semitone),\r\n              time: timer.getTime(delta) - note.offset,\r\n              amplitude: note.velocity / 128,\r\n              offset: note.offset,\r\n            });\r\n\r\n            // to determine maximum total velocity for normalizing volume\r\n            events.push({velocity: note.velocity, delta, note: false});\r\n          }\r\n        } else if (args.verbose && event.type === 'meta') {\r\n          if (typeof event.value === 'string') {\r\n            console.log(`${timer.getTime(delta).toFixed(2)}s ${event.subType}: ${event.value}`);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (args.verbose) {\r\n      console.log('normalizing volume...');\r\n    }\r\n\r\n    events.sort(function (a, b) {\r\n      return a.delta - b.delta || a.note - b.note;\r\n    });\r\n\r\n    if (args.verbose) {\r\n      console.log('total notes:', progression.length);\r\n      console.log('total time:', timer.getTime(events[events.length - 1].delta), 'seconds');\r\n    }\r\n\r\n    let maxVelocity = 1;\r\n    let maxVelocityTime = 0;\r\n    let velocity = 1;\r\n    let maxChord = 0;\r\n    let maxChordTime = 0;\r\n    let chord = 0;\r\n\r\n    for (const event of events) {\r\n      if (event.note) {\r\n        velocity += event.velocity;\r\n        chord++;\r\n\r\n        if (velocity > maxVelocity) {\r\n          maxVelocity = velocity;\r\n          maxVelocityTime = timer.getTime(event.delta);\r\n        }\r\n\r\n        if (chord > maxChord) {\r\n          maxChord = chord;\r\n          maxChordTime = timer.getTime(event.delta);\r\n        }\r\n      } else {\r\n        velocity -= event.velocity;\r\n        chord--;\r\n      }\r\n    }\r\n\r\n    // scaling factor for amplitude\r\n    maxAmplitude = 128 / maxVelocity;\r\n\r\n    if (args.verbose) {\r\n      console.log('setting volume to', maxAmplitude);\r\n      console.log('  maximum chord of', maxChord, 'at', maxChordTime, 'seconds');\r\n      console.log('  maximum velocity of', maxVelocity - 1, 'at', maxVelocityTime, 'seconds');\r\n    }\r\n  } else {\r\n    // use frames per second\r\n    // not yet implemented\r\n\r\n    console.log('Detected unsupported MIDI timing mode');\r\n\r\n    return null;\r\n\r\n    /*\r\n    let framesPerSecond = (division >>> 8) & 0x7F;\r\n    let ticksPerFrame = division & 0xFF;\r\n\r\n    if (framesPerSecond === 29) {\r\n      framesPerSecond = 29.97;\r\n    }\r\n\r\n    // seconds per tick = 1 / frames per second / ticks per frame\r\n    secsPerTick = 1 / framesPerSecond / ticksPerFrame;\r\n    */\r\n  }\r\n\r\n  // set to mono\r\n  args.channels = 1;\r\n\r\n  if (args.verbose) {\r\n    console.log('generating WAV buffer...');\r\n  }\r\n\r\n  const wav = new WAV(args.channels, args.sampleRate, args.bitsPerSample);\r\n\r\n  wav.writeProgression(progression, maxAmplitude, [0], true, true, args.duration);\r\n\r\n  return wav;\r\n};\r\n","'use strict';\r\n\r\n// utility class to calculate time from delta ticks\r\n// when MIDI file has several `setTempo` events\r\nclass Timer {\r\n  constructor(ticksPerBeat) {\r\n    this.ticksPerBeat = ticksPerBeat;\r\n    this.criticalPoints = [];\r\n  }\r\n\r\n  // delta represents ticks since last time change\r\n  addCriticalPoint(delta, microsecondsPerBeat) {\r\n    this.criticalPoints.push({\r\n      delta,\r\n      microsecondsPerBeat\r\n    });\r\n  }\r\n\r\n  getTime(delta) {\r\n    const microsecondsPerSecond = 1000000;\r\n    let time = 0;\r\n    // midi standard initializes file with this value\r\n    let microsecondsPerBeat = 500000;\r\n\r\n    // iterate through time changes while decrementing delta ticks to 0\r\n    for (let i = 0, criticalPoint; i < this.criticalPoints.length && delta > 0; i++) {\r\n      criticalPoint = this.criticalPoints[i];\r\n\r\n      // incrementally calculate the time passed for each range of timing\r\n      if (delta >= criticalPoint.delta) {\r\n        time += criticalPoint.delta * microsecondsPerBeat / this.ticksPerBeat / microsecondsPerSecond;\r\n        delta -= criticalPoint.delta;\r\n      } else {\r\n        time += delta * microsecondsPerBeat / this.ticksPerBeat / microsecondsPerSecond;\r\n        delta = 0;\r\n      }\r\n\r\n      microsecondsPerBeat = criticalPoint.microsecondsPerBeat;\r\n    }\r\n\r\n    time += delta * microsecondsPerBeat / this.ticksPerBeat / microsecondsPerSecond;\r\n\r\n    return time;\r\n  }\r\n};\r\n\r\nmodule.exports = Timer;\r\n","'use strict';\r\n\r\nclass WAV {\r\n  static semitone(note = 'REST') {\r\n    // matches occurence of A through G\r\n    // followed by positive or negative integer\r\n    // followed by 0 to 2 occurences of flat or sharp\r\n    const re = /^([A-G])(\\-?\\d+)(b{0,2}|#{0,2})$/;\r\n\r\n    // if semitone is unrecognized, assume REST\r\n    if (!re.test(note)) {\r\n      return -Infinity;\r\n    }\r\n\r\n    // parse substrings of note\r\n    const [, tone, octave, accidental] = note.match(re);\r\n\r\n    // semitone indexed relative to A4 == 69 for compatibility with MIDI\r\n    const tones = {C: 0, D: 2, E: 4, F: 5, G: 7, A: 9, B: 11};\r\n    const octaves = {'-1': 0, 0: 1, 1: 2, 2: 3, 3: 4, 4: 5, 5: 6, 6: 7, 7: 8, 8: 9, 9: 10, 10: 11};\r\n    const accidentals = {bb: -2, b: -1, '': 0, '#': 1, '##': 2};\r\n\r\n    // if semitone is unrecognized, assume REST\r\n    if (tones[tone] === undefined || octaves[octave] === undefined || accidentals[accidental] === undefined) {\r\n      return -Infinity;\r\n    }\r\n\r\n    // return calculated index\r\n    return tones[tone] + octaves[octave] * 12 + accidentals[accidental];\r\n  }\r\n\r\n  static note(semitone = -Infinity) {\r\n    const octaves = [-1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\r\n    const tones = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];\r\n\r\n    const octaveIndex = Math.floor(semitone / 12);\r\n    const toneIndex = Math.floor(semitone - octaveIndex * 12);\r\n\r\n    const octave = octaves[octaveIndex];\r\n    const tone = tones[toneIndex];\r\n\r\n    // by default assume REST\r\n    if (octave === undefined || tone === undefined) {\r\n      return 'REST';\r\n    }\r\n\r\n    // tone followed by octave followed by accidental\r\n    return tone.charAt(0) + octave.toString() + tone.charAt(1);\r\n  }\r\n\r\n  // converts semitone index to frequency in Hz\r\n  static frequency(semitone = -Infinity) {\r\n    // A4 is 440 Hz, 12 semitones per octave\r\n    return 440 * Math.pow(2, (semitone - 69) / 12);\r\n  }\r\n\r\n  constructor(numChannels = 1, sampleRate = 44100, bitsPerSample = 16, littleEndian = true, data = []) {\r\n    var bytesPerSample = bitsPerSample >>> 3;\r\n    // WAV header is always 44 bytes\r\n    this.header = new ArrayBuffer(44);\r\n    // flexible container for reading / writing raw bytes in header\r\n    this.view = new DataView(this.header);\r\n    // leave sound data as non typed array for more flexibility\r\n    this.data = data;\r\n\r\n    // initialize as non-configurable because it\r\n    // causes script to freeze when using parsed\r\n    // chunk sizes with wrong endianess assumed\r\n    Object.defineProperty(this, 'littleEndian', {\r\n      configurable: false,\r\n      enumerable: true,\r\n      value: littleEndian,\r\n      writable: false\r\n    });\r\n\r\n    // initial write index in data array\r\n    this.pointer = 0;\r\n\r\n    // WAV header properties\r\n    this.ChunkID = littleEndian ? 'RIFF' : 'RIFX';\r\n    this.ChunkSize = this.header.byteLength - 8;\r\n    this.Format = 'WAVE';\r\n    this.SubChunk1ID = 'fmt ';\r\n    this.SubChunk1Size = 16;\r\n    this.AudioFormat = 1;\r\n    this.NumChannels = numChannels;\r\n    this.SampleRate = sampleRate;\r\n    this.ByteRate = numChannels * sampleRate * bytesPerSample;\r\n    this.BlockAlign = numChannels * bytesPerSample;\r\n    this.BitsPerSample = bitsPerSample;\r\n    this.SubChunk2ID = 'data';\r\n    this.SubChunk2Size = data.length * bytesPerSample;\r\n  }\r\n\r\n  // internal setter for writing strings as raw bytes to header\r\n  setString(str, byteLength = str.length, byteOffset = 0) {\r\n    for (var i = 0; i < byteLength; i++) {\r\n      this.view.setUint8(byteOffset + i, str.charCodeAt(i));\r\n    }\r\n  }\r\n\r\n  // internal getter for reading raw bytes as strings from header\r\n  getString(byteLength, byteOffset = 0) {\r\n    for (var i = 0, str = ''; i < byteLength; i++) {\r\n      str += String.fromCharCode(this.view.getUint8(byteOffset + i));\r\n    }\r\n\r\n    return str;\r\n  }\r\n\r\n  // header property mutators\r\n\r\n  // 4 bytes at offset of 0 bytes\r\n  set ChunkID(str) {\r\n    this.setString(str, 4, 0);\r\n  }\r\n\r\n  get ChunkID() {\r\n    return this.getString(4, 0);\r\n  }\r\n\r\n  // 4 bytes at offset of 4 bytes\r\n  set ChunkSize(uint) {\r\n    this.view.setUint32(4, uint, this.littleEndian);\r\n  }\r\n\r\n  get ChunkSize() {\r\n    return this.view.getUint32(4, this.littleEndian);\r\n  }\r\n\r\n  // 4 bytes at offset of 8 bytes\r\n  set Format(str) {\r\n    this.setString(str, 4, 8);\r\n  }\r\n\r\n  get Format() {\r\n    return this.getString(4, 8);\r\n  }\r\n\r\n  // 4 bytes at offset of 12 bytes\r\n  set SubChunk1ID(str) {\r\n    this.setString(str, 4, 12);\r\n  }\r\n\r\n  get SubChunk1ID() {\r\n    return this.getString(4, 12);\r\n  }\r\n\r\n  // 4 bytes at offset of 16 bytes\r\n  set SubChunk1Size(uint) {\r\n    this.view.setUint32(16, uint, this.littleEndian);\r\n  }\r\n\r\n  get SubChunk1Size() {\r\n    return this.view.getUint32(16, this.littleEndian);\r\n  }\r\n\r\n  // 2 bytes at offset of 20 bytes\r\n  set AudioFormat(uint) {\r\n    this.view.setUint16(20, uint, this.littleEndian);\r\n  }\r\n\r\n  get AudioFormat() {\r\n    return this.view.getUint16(20, this.littleEndian);\r\n  }\r\n\r\n  // 2 bytes at offset of 22 bytes\r\n  set NumChannels(uint) {\r\n    this.view.setUint16(22, uint, this.littleEndian);\r\n  }\r\n\r\n  get NumChannels() {\r\n    return this.view.getUint16(22, this.littleEndian);\r\n  }\r\n\r\n  // 4 bytes at offset of 24 bytes\r\n  set SampleRate(uint) {\r\n    this.view.setUint32(24, uint, this.littleEndian);\r\n  }\r\n\r\n  get SampleRate() {\r\n    return this.view.getUint32(24, this.littleEndian);\r\n  }\r\n\r\n  // 4 bytes at offset of 28 bytes\r\n  set ByteRate(uint) {\r\n    this.view.setUint32(28, uint, this.littleEndian);\r\n  }\r\n\r\n  get ByteRate() {\r\n    return this.view.getUint32(28, this.littleEndian);\r\n  }\r\n\r\n  // 2 bytes at offset of 32 bytes\r\n  set BlockAlign(uint) {\r\n    this.view.setUint16(32, uint, this.littleEndian);\r\n  }\r\n\r\n  get BlockAlign() {\r\n    return this.view.getUint16(32, this.littleEndian);\r\n  }\r\n\r\n  // 2 bytes at offset of 34 bytes\r\n  set BitsPerSample(uint) {\r\n    this.view.setUint16(34, uint, this.littleEndian);\r\n  }\r\n\r\n  get BitsPerSample() {\r\n    return this.view.getUint16(34, this.littleEndian);\r\n  }\r\n\r\n  // 4 bytes at offset of 36 bytes\r\n  set SubChunk2ID(str) {\r\n    this.setString(str, 4, 36);\r\n  }\r\n\r\n  get SubChunk2ID() {\r\n    return this.getString(4, 36);\r\n  }\r\n\r\n  // 4 bytes at offset of 40 bytes\r\n  set SubChunk2Size(uint) {\r\n    this.view.setUint32(40, uint, this.littleEndian);\r\n  }\r\n\r\n  get SubChunk2Size() {\r\n    return this.view.getUint32(40, this.littleEndian);\r\n  }\r\n\r\n  // internal getter for sound data as\r\n  // typed array based on header properties\r\n  get typedData() {\r\n    var bytesPerSample = this.BitsPerSample >>> 3;\r\n    var data = this.data;\r\n    var size = this.SubChunk2Size;\r\n    var samples = size / bytesPerSample;\r\n    var buffer = new ArrayBuffer(size);\r\n    var uint8 = new Uint8Array(buffer);\r\n\r\n    // convert signed normalized sound data to typed integer data\r\n    // i.e. [-1, 1] -> [INT_MIN, INT_MAX]\r\n    var amplitude = Math.pow(2, (bytesPerSample << 3) - 1) - 1;\r\n    var i, d;\r\n\r\n    switch (bytesPerSample) {\r\n    case 1:\r\n      // endianess not relevant for 8-bit encoding\r\n      for (i = 0; i < samples; i++) {\r\n        // convert by adding 0x80 instead of 0x100\r\n        // WAV uses unsigned data for 8-bit encoding\r\n\r\n        // [INT8_MIN, INT8_MAX] -> [0, UINT8_MAX]\r\n        uint8[i] = (data[i] * amplitude + 0x80) & 0xFF;\r\n      }\r\n      break;\r\n    case 2:\r\n      // LSB first\r\n      if (this.littleEndian) {\r\n        for (i = 0; i < samples; i++) {\r\n          // [INT16_MIN, INT16_MAX] -> [0, UINT16_MAX]\r\n          d = (data[i] * amplitude + 0x10000) & 0xFFFF;\r\n\r\n          // unwrap inner loop\r\n          uint8[i * 2    ] = (d      ) & 0xFF;\r\n          uint8[i * 2 + 1] = (d >>> 8);\r\n        }\r\n      // MSB first\r\n      } else {\r\n        for (i = 0; i < samples; i++) {\r\n          // [INT16_MIN, INT16_MAX] -> [0, UINT16_MAX]\r\n          d = (data[i] * amplitude + 0x10000) & 0xFFFF;\r\n\r\n          // unwrap inner loop\r\n          uint8[i * 2    ] = (d >>> 8);\r\n          uint8[i * 2 + 1] = (d      ) & 0xFF;\r\n        }\r\n      }\r\n      break;\r\n    case 3:\r\n      // LSB first\r\n      if (this.littleEndian) {\r\n        for (i = 0; i < samples; i++) {\r\n          // [INT24_MIN, INT24_MAX] -> [0, UINT24_MAX]\r\n          d = (data[i] * amplitude + 0x1000000) & 0xFFFFFF;\r\n\r\n          // unwrap inner loop\r\n          uint8[i * 3    ] = (d       ) & 0xFF;\r\n          uint8[i * 3 + 1] = (d >>>  8) & 0xFF;\r\n          uint8[i * 3 + 2] = (d >>> 16);\r\n        }\r\n      // MSB first\r\n      } else {\r\n        for (i = 0; i < samples; i++) {\r\n          // [INT24_MIN, INT24_MAX] -> [0, UINT24_MAX]\r\n          d = (data[i] * amplitude + 0x1000000) & 0xFFFFFF;\r\n\r\n          // unwrap inner loop\r\n          uint8[i * 3    ] = (d >>> 16);\r\n          uint8[i * 3 + 1] = (d >>>  8) & 0xFF;\r\n          uint8[i * 3 + 2] = (d       ) & 0xFF;\r\n        }\r\n      }\r\n    case 4:\r\n      // LSB first\r\n      if (this.littleEndian) {\r\n        for (i = 0; i < samples; i++) {\r\n          // [INT32_MIN, INT32_MAX] -> [0, UINT32_MAX]\r\n          d = (data[i] * amplitude + 0x100000000) & 0xFFFFFFFF;\r\n\r\n          // unwrap inner loop\r\n          uint8[i * 4    ] = (d       ) & 0xFF;\r\n          uint8[i * 4 + 1] = (d >>>  8) & 0xFF;\r\n          uint8[i * 4 + 2] = (d >>> 16) & 0xFF;\r\n          uint8[i * 4 + 3] = (d >>> 24);\r\n        }\r\n      // MSB first\r\n      } else {\r\n        for (i = 0; i < samples; i++) {\r\n          // [INT32_MIN, INT32_MAX] -> [0, UINT32_MAX]\r\n          d = (data[i] * amplitude + 0x100000000) & 0xFFFFFFFF;\r\n\r\n          // unwrap inner loop\r\n          uint8[i * 4    ] = (d >>> 24);\r\n          uint8[i * 4 + 1] = (d >>> 16) & 0xFF;\r\n          uint8[i * 4 + 2] = (d >>>  8) & 0xFF;\r\n          uint8[i * 4 + 3] = (d       ) & 0xFF;\r\n        }\r\n      }\r\n    }\r\n\r\n    return buffer;\r\n  }\r\n\r\n  // binary container outputs\r\n\r\n  // browser-specific\r\n  // generates blob from concatenated typed arrays\r\n  toBlob() {\r\n    return new Blob([this.header, this.typedData], {type: 'audio/wav'});\r\n  }\r\n\r\n  // Node.js-specific\r\n  // generates buffer from concatenated typed arrays\r\n  toBuffer() {\r\n    return Buffer.concat([Buffer.from(this.header), Buffer.from(this.typedData)]);\r\n  }\r\n\r\n  // pointer mutators\r\n\r\n  // gets time (in seconds) of pointer\r\n  tell() {\r\n    return this.pointer / this.NumChannels / this.SampleRate;\r\n  }\r\n\r\n  // sets time (in seconds) of pointer\r\n  // zero-fills by default\r\n  seek(time, fill = true) {\r\n    var data   = this.data;\r\n    var sample = Math.round(this.SampleRate * time);\r\n\r\n    this.pointer = this.NumChannels * sample;\r\n\r\n    if (fill) {\r\n      // zero-fill seek\r\n      while (data.length < this.pointer) {\r\n        data[data.length] = 0;\r\n      }\r\n    } else {\r\n      this.pointer = data.length;\r\n    }\r\n  }\r\n\r\n  // sound data mutators\r\n\r\n  // writes the specified note to the sound data\r\n  // for amount of time in seconds\r\n  // at given normalized amplitude\r\n  // to channels listed (or all by default)\r\n  // adds to existing data by default\r\n  // and does not reset write index after operation by default\r\n  writeNote({note, time, amplitude = 1}, channels = [], blend = true, reset = false) {\r\n    // creating local references to properties\r\n    var data = this.data;\r\n    var numChannels = this.NumChannels;\r\n    var sampleRate = this.SampleRate;\r\n\r\n    // to prevent sound artifacts\r\n    const fadeSeconds = 0.001;\r\n\r\n    // calculating properties of given note\r\n    var semitone = WAV.semitone(note);\r\n    var frequency = WAV.frequency(semitone) * Math.PI * 2 / sampleRate;\r\n    var period = Math.PI * 2 / frequency;\r\n\r\n    // amount of blocks to be written\r\n    var blocksOut = Math.round(sampleRate * time);\r\n    // reduces sound artifacts by fading at last fadeSeconds\r\n    var nonZero = blocksOut - sampleRate * fadeSeconds;\r\n    // fade interval in samples\r\n    var fade = blocksOut - nonZero + 1;\r\n\r\n    // index of start and stop samples\r\n    var start = this.pointer;\r\n    var stop = data.length;\r\n\r\n    // determines amount of blocks to be updated\r\n    var blocksIn = Math.min(Math.floor((stop - start) / numChannels), blocksOut);\r\n\r\n    // i = index of each sample block\r\n    // j = index of each channel in a block\r\n    // k = cached index of data\r\n    // d = sample data value\r\n    var i, j, k, d;\r\n\r\n    // by default write to all channels\r\n    if (channels.length === 0) {\r\n      // don't overwrite passed array\r\n      channels = [];\r\n\r\n      for (i = 0; i < numChannels; i++) {\r\n        channels[i] = i;\r\n      }\r\n    }\r\n\r\n    // inline .indexOf() function calls into array references\r\n    var skipChannel = [];\r\n\r\n    for (i = 0; i < numChannels; i++) {\r\n      skipChannel[i] = (channels.indexOf(i) === -1);\r\n    }\r\n\r\n    // update existing data\r\n    for (i = 0; i < blocksIn; i++) {\r\n      // iterate through specified channels\r\n      for (j = 0; j < channels.length; j++) {\r\n        k = start + i * numChannels + channels[j];\r\n        d = 0;\r\n\r\n        if (frequency > 0) {\r\n          d = amplitude * Math.sin(frequency * i) * ((i < fade) ? i : (i > nonZero) ? blocksOut - i + 1 : fade) / fade;\r\n        }\r\n\r\n        data[k] = d + (blend ? data[k] : 0);\r\n      }\r\n    }\r\n\r\n    // append data\r\n    for (i = blocksIn; i < blocksOut; i++) {\r\n      k = start + i * numChannels;\r\n\r\n      // iterate through all channels\r\n      for (j = 0; j < numChannels; j++) {\r\n        d = 0;\r\n\r\n        // only write non-zero data to specified channels\r\n        if (frequency > 0 || !skipChannel[j]) {\r\n          d = amplitude * Math.sin(frequency * i) * ((i < fade) ? i : (i > nonZero) ? blocksOut - i + 1 : fade) / fade;\r\n        }\r\n\r\n        data[k + j] = d;\r\n      }\r\n    }\r\n\r\n    // update header properties\r\n    var end = Math.max(start + blocksOut * numChannels, stop) * this.BitsPerSample >>> 3;\r\n\r\n    this.ChunkSize = end + this.header.byteLength - 8;\r\n    this.SubChunk2Size = end;\r\n\r\n    if (!reset) {\r\n      // move write index to end of written data\r\n      this.pointer = start + blocksOut * numChannels;\r\n    }\r\n  }\r\n\r\n  // adds specified notes in series\r\n  // (or asynchronously if offset property is specified in a note)\r\n  // each playing for time * relativeDuration seconds\r\n  // followed by a time * (1 - relativeDuration) second rest\r\n  writeProgression(notes, amplitude = 1, channels = [], blend = true, reset = false, relativeDuration = 1) {\r\n    var start = this.pointer;\r\n\r\n    for (var i = 0, note, time, amp, off, secs, rest; i < notes.length; i++) {\r\n      ({note, time, amplitude: amp, offset: off} = notes[i]);\r\n\r\n      // for asynchronous progression\r\n      if (off !== undefined) {\r\n        this.seek(off);\r\n      }\r\n\r\n      if (relativeDuration === 1 || note === 'REST') {\r\n        this.writeNote({note, time, amplitude: amp === undefined ? amplitude : amp * amplitude}, channels, blend, false);\r\n      } else {\r\n        secs = time * relativeDuration;\r\n        rest = time - secs;\r\n\r\n        this.writeNote({note: note, time: secs, amplitude: amp === undefined ? amplitude : amp * amplitude}, channels, blend, false);\r\n        this.writeNote({note: 'REST', time: rest}, channels, blend, false);\r\n      }\r\n    }\r\n\r\n    if (reset) {\r\n      this.pointer = start;\r\n    }\r\n  }\r\n};\r\n\r\nmodule.exports = WAV;\r\n"]}